{"version":3,"sources":["algorithms/NodeType.tsx","algorithms/Dijkstra.tsx","algorithms/Vertex.tsx","hooks/useMouseEventHandlers.tsx","components/Node.tsx","components/PathfindingVisualizer.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["NodeType","Dijkstra","grid","startNode","endNode","openSet","visited","distance","length","current","pop","isVisited","push","updateNeighbors","nodes","sort","nodeA","nodeB","shift","node","neighbors","i","j","filter","neighbor","isWall","getNeighbors","prevNode","includes","Vertex","nodeType","Default","Infinity","this","Start","End","Wall","useMouseEventHandlers","start","end","setGrid","setStart","setEnd","resetGrid","useState","isMousePressed","setIsMousePressed","isDraggingStart","setIsDraggingStart","isDraggingEnd","setIsDraggingEnd","isUpdatingToWall","setIsUpdatingToWall","updateWall","newType","newNode","newGrid","slice","handleMouseDown","handleMouseEnter","updateStart","updateEnd","handleMouseUp","useStyles","makeStyles","theme","item","props","border","gridRow","gridCol","backgroundColor","vertex","wall","Node","classes","classWall","className","ref","nodeRef","title","onMouseDown","onMouseEnter","onMouseUp","container","display","gridTemplateRows","nRows","gridTemplateColumns","nCols","justifyContent","margin","shortestPath","buttons","width","PathfindingVisualizer","p","startEnd","Math","trunc","initialRefs","Array","from","_","createRef","refs","initialGrid","initialNodeType","forEach","row","reset","classList","remove","resetWall","probWall","isStartOrEnd","random","setWall","clearWall","useEffect","handlers","animate","visitedNodes","setTimeout","add","animateShortestPath","Button","variant","style","textTransform","onClick","path","unshift","backtrackToStart","map","paper","flexGrow","maxWidth","padding","spacing","textAlign","color","fontWeight","App","url","Paper","elevation","href","Typography","gutterBottom","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c2a52fea.chunk.js","sourcesContent":["export enum NodeType {\n  Default,\n  Start,\n  End,\n  Wall,\n}\n","import { Vertex } from \"./Vertex\";\n\nexport function Dijkstra(grid: Vertex[][], startNode: Vertex, endNode: Vertex) {\n  const openSet = [startNode]\n  const visited: Vertex[] = []\n  startNode.distance = 0\n\n  while (!!openSet.length) {\n    const current = pop(openSet)\n\n    if (current === endNode) return visited\n\n    current.isVisited = true\n    visited.push(current)\n\n    updateNeighbors(current)\n  }\n\n  return visited  // when could not reach to the end node\n\n  // works like a priority queue\n  function pop(nodes: Vertex[]) {\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n    return nodes.shift()!\n  }\n\n  function updateNeighbors(node: Vertex) {\n    const neighbors = getNeighbors(node)\n\n    for (const neighbor of neighbors) {\n      neighbor.distance = node.distance + 1\n      neighbor.prevNode = node\n\n      if (!openSet.includes(neighbor))\n        openSet.push(neighbor)\n    }\n  }\n\n  function getNeighbors(node: Vertex) {\n    const neighbors = []\n    const { i, j } = node\n\n    if (i > 0)\n      neighbors.push(grid[i - 1][j])\n    if (i < grid.length - 1)\n      neighbors.push(grid[i + 1][j])\n    if (j > 0)\n      neighbors.push(grid[i][j - 1])\n    if (j < grid[0].length - 1)\n      neighbors.push(grid[i][j + 1])\n\n    return neighbors.filter(neighbor =>\n      !neighbor.isWall() &&\n      !neighbor.isVisited\n    )\n  }\n}\n\nexport function backtrackToStart(node: Vertex) {\n  const path = [node]\n\n  while (node.prevNode) {\n    path.unshift(node.prevNode)\n    node = node.prevNode!\n  }\n\n  return path\n}\n","import { NodeType } from \"./NodeType\";\n\nexport class Vertex {\n  constructor(\n    readonly i: number,\n    readonly j: number,\n    public nodeType: NodeType = NodeType.Default,\n    public distance: number = Infinity,\n    public prevNode: Vertex | null = null,\n    public isVisited: boolean = false,\n  ) { }\n\n  public reset() {\n    this.distance = Infinity\n    this.prevNode = null\n    this.isVisited = false\n  }\n\n  public isStartOrEnd() {\n    return this.nodeType === NodeType.Start || this.nodeType === NodeType.End\n  }\n\n  public isWall() {\n    return this.nodeType === NodeType.Wall\n  }\n\n  public setWall() {\n    this.nodeType = NodeType.Wall\n  }\n\n  public clearWall() {\n    this.nodeType = NodeType.Default\n  }\n}\n","import { Dispatch, SetStateAction, useState } from \"react\";\nimport { NodeType } from \"../algorithms/NodeType\";\nimport { Vertex } from \"../algorithms/Vertex\";\nimport { Coordinates } from \"../components/Coordinates\";\n\nconst useMouseEventHandlers = (\n  grid: Vertex[][],\n  start: Coordinates,\n  end: Coordinates,\n  setGrid: Dispatch<SetStateAction<Vertex[][]>>,\n  setStart: Dispatch<SetStateAction<Coordinates>>,\n  setEnd: Dispatch<SetStateAction<Coordinates>>,\n  resetGrid: () => void,\n) => {\n  const [isMousePressed, setIsMousePressed] = useState<boolean>(false);\n  const [isDraggingStart, setIsDraggingStart] = useState<boolean>(false);\n  const [isDraggingEnd, setIsDraggingEnd] = useState<boolean>(false);\n  const [isUpdatingToWall, setIsUpdatingToWall] = useState<boolean>(false);\n\n  const updateStart = (i: number, j: number) => {\n    const newGrid = grid.slice()\n\n    newGrid[start.i][start.j] = new Vertex(start.i, start.j)\n    newGrid[i][j] = new Vertex(i, j, NodeType.Start)\n\n    setGrid(newGrid)\n    setStart({ i, j })\n  }\n\n  const updateEnd = (i: number, j: number) => {\n    const newGrid = grid.slice()\n\n    newGrid[end.i][end.j] = new Vertex(end.i, end.j)\n    newGrid[i][j] = new Vertex(i, j, NodeType.End)\n\n    setGrid(newGrid)\n    setEnd({ i, j })\n  }\n\n  const updateWall = (i: number, j: number) => {\n    const newType = isUpdatingToWall ? NodeType.Wall : NodeType.Default\n    const newNode = new Vertex(i, j, newType)\n\n    const newGrid = grid.slice()\n    newGrid[i][j] = newNode\n\n    setGrid(newGrid)\n  }\n\n  const handleMouseDown = (i: number, j: number) => {\n    setIsMousePressed(true)\n\n    if (grid[i][j].nodeType === NodeType.Start) {\n      setIsDraggingStart(true)\n    } else if (grid[i][j].nodeType === NodeType.End) {\n      setIsDraggingEnd(true)\n    } else {\n      updateWall(i, j)\n    }\n  }\n\n  const handleMouseEnter = (i: number, j: number) => {\n    setIsUpdatingToWall(grid[i][j].nodeType !== NodeType.Wall)\n    if (!isMousePressed) return\n\n    if (isDraggingStart) {\n      updateStart(i, j)\n    } else if (isDraggingEnd) {\n      updateEnd(i, j)\n    } else {\n      updateWall(i, j)\n    }\n  }\n\n  const handleMouseUp = (i: number, j: number) => {\n    setIsMousePressed(false)\n\n    if (isDraggingStart || isDraggingEnd)\n      resetGrid()\n\n    setIsDraggingStart(false)\n    setIsDraggingEnd(false)\n    setIsUpdatingToWall(grid[i][j].nodeType !== NodeType.Wall)\n  }\n\n  return {\n    handleMouseDown,\n    handleMouseEnter,\n    handleMouseUp,\n  }\n}\n\nexport default useMouseEventHandlers\n","import { makeStyles, Theme } from '@material-ui/core';\nimport React, { RefObject } from 'react';\nimport { NodeType } from '../algorithms/NodeType';\nimport { Vertex } from '../algorithms/Vertex';\n\nconst useStyles = makeStyles<Theme, Props>((theme) => ({\n  item: props => ({\n    border: \"1px solid lightgray\",\n    gridRow: `${props.i + 1}`,\n    gridCol: `${props.j + 1}`,\n    backgroundColor: `${props.vertex.nodeType === NodeType.Start ? 'green' : props.vertex.nodeType === NodeType.End ? 'red' : ''}`\n  }),\n  wall: {\n    backgroundColor: 'black'\n  },\n}));\n\ntype Props = {\n  i: number\n  j: number\n  nodeRef: RefObject<HTMLDivElement>\n  vertex: Vertex\n  handleMouseDown: (i: number, j: number) => void\n  handleMouseEnter: (i: number, j: number) => void\n  handleMouseUp: (i: number, j: number) => void\n}\n\nfunction Node(props: Props) {\n  const classes = useStyles(props);\n\n  const handleMouseDown = () => {\n    props.handleMouseDown(props.i, props.j)\n  }\n\n  const handleMouseEnter = () => {\n    props.handleMouseEnter(props.i, props.j)\n  }\n\n  const handleMouseUp = () => {\n    props.handleMouseUp(props.i, props.j)\n  }\n\n  const classWall = props.vertex.nodeType === NodeType.Wall ? classes.wall : ''\n\n  return (\n    <div\n      className={`${classes.item} ${classWall}`}\n      ref={props.nodeRef}\n      title={`${props.i}, ${props.j}`}\n      onMouseDown={handleMouseDown}\n      onMouseEnter={handleMouseEnter}\n      onMouseUp={handleMouseUp}\n    />\n  )\n}\n\nexport default Node\n","import { Button, makeStyles, Theme } from '@material-ui/core';\nimport React, { createRef, RefObject, useEffect, useState } from 'react';\nimport { backtrackToStart, Dijkstra } from '../algorithms/Dijkstra';\nimport { NodeType } from '../algorithms/NodeType';\nimport { Vertex } from '../algorithms/Vertex';\nimport useMouseEventHandlers from '../hooks/useMouseEventHandlers';\nimport { Coordinates } from './Coordinates';\nimport Node from './Node';\n\nconst useStyles = makeStyles<Theme, Props>((theme) => ({\n  container: props => ({\n    display: 'grid',\n    gridTemplateRows: `repeat(${props.nRows}, 20px)`,\n    gridTemplateColumns: `repeat(${props.nCols}, 20px)`,\n    justifyContent: 'center',\n    margin: '50px auto',\n  }),\n  visited: {\n    backgroundColor: 'lightgreen'\n  },\n  shortestPath: {\n    backgroundColor: 'yellow'\n  },\n  buttons: {\n    display: 'flex',\n    justifyContent: 'center',\n    width: '100%',\n    margin: '10px auto',\n  },\n}));\n\nconst initialStartEnd = (p: Props): Coordinates[] => {\n  return [\n    { i: Math.trunc(p.nRows / 2), j: Math.trunc(p.nCols / 5) },\n    { i: Math.trunc(p.nRows / 2), j: Math.trunc(p.nCols * 4 / 5) - 1 }\n  ]\n}\n\nconst initialNodeType = (i: number, j: number, start: Coordinates, end: Coordinates) => {\n  return (\n    i === start.i && j === start.j ? NodeType.Start :\n      i === end.i && j === end.j ? NodeType.End :\n        NodeType.Default\n  )\n}\n\ntype Props = {\n  nRows: number\n  nCols: number\n}\n\nfunction PathfindingVisualizer(props: Props) {\n  const classes = useStyles(props);\n\n  const startEnd = initialStartEnd(props)\n  const [start, setStart] = useState<Coordinates>(startEnd[0]);\n  const [end, setEnd] = useState<Coordinates>(startEnd[1]);\n\n  const initialRefs =\n    Array.from({ length: props.nRows }, _ =>\n      Array.from({ length: props.nCols }, _ =>\n        createRef<HTMLDivElement>()\n      )\n    )\n  const [refs] = useState<RefObject<HTMLDivElement>[][]>(initialRefs);\n\n  const initialGrid =\n    Array.from({ length: props.nRows }, (_, i) =>\n      Array.from({ length: props.nCols }, (_, j) => {\n        const nodeType = initialNodeType(i, j, start, end)\n        return new Vertex(i, j, nodeType)\n      })\n    )\n  const [grid, setGrid] = useState<Vertex[][]>(initialGrid);\n\n  const resetGrid = () => {\n    refs.forEach((row, i) =>\n      row.forEach((ref, j) => {\n        grid[i][j].reset()\n        ref.current?.classList.remove(classes.visited, classes.shortestPath)\n      })\n    )\n  }\n\n  const resetWall = (probWall: number) => {\n    refs.forEach((row, i) =>\n      row.forEach((ref, j) => {\n        if (grid[i][j].isStartOrEnd()) return\n\n        if (Math.random() < probWall) {\n          grid[i][j].setWall()\n        } else {\n          grid[i][j].clearWall()\n        }\n      })\n    )\n\n    resetGrid()\n    setStart({ i: start.i, j: start.j }) // force re-render\n  }\n\n  useEffect(() => {\n    resetWall(0.35)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  const handlers = useMouseEventHandlers(grid, start, end, setGrid, setStart, setEnd, resetGrid)\n\n  const visualize = () => {\n    resetGrid()\n\n    const startNode = grid[start.i][start.j]\n    const endNode = grid[end.i][end.j]\n    const visitedNodes = Dijkstra(grid, startNode, endNode);\n    const shortestPath = backtrackToStart(endNode);\n\n    animate(visitedNodes, shortestPath);\n  }\n\n  const animate = (visitedNodes: Vertex[], shortestPath: Vertex[]) => {\n    for (let i = 1; i < visitedNodes.length - 1; i++) {\n      setTimeout(() => {\n        const node = visitedNodes[i];\n        const ref = refs[node.i][node.j].current!\n        ref.classList.add(classes.visited)\n      }, 10 * i);\n\n      if (i === visitedNodes.length - 2) {\n        setTimeout(() => {\n          animateShortestPath(shortestPath);\n        }, 10 * i);\n        return;\n      }\n    }\n  }\n\n  const animateShortestPath = (shortestPath: Vertex[]) => {\n    for (let i = 1; i < shortestPath.length - 1; i++) {\n      setTimeout(() => {\n        const node = shortestPath[i];\n        const ref = refs[node.i][node.j].current!\n        ref.classList.add(classes.shortestPath)\n      }, 50 * i);\n    }\n  }\n\n  return (\n    <>\n      <div className={classes.buttons}>\n        <Button variant=\"contained\" style={{ textTransform: 'none' }} onClick={() => resetWall(0.35)}>\n          Random Wall\n        </Button>\n        <Button variant=\"contained\" style={{ textTransform: 'none' }} onClick={() => resetWall(0)}>\n          Clear Wall\n        </Button>\n      </div>\n      <Button variant=\"contained\" style={{ textTransform: 'none' }} onClick={visualize}>\n        Visualize Dijkstra's Algorithm\n      </Button>\n      <div className={classes.container}>\n        {\n          refs.map((row, i) =>\n            row.map((node, j) =>\n              <Node\n                i={i} j={j}\n                key={`node-${i}-${j}`}\n                nodeRef={node}\n                vertex={grid[i][j]}\n                handleMouseDown={handlers.handleMouseDown}\n                handleMouseEnter={handlers.handleMouseEnter}\n                handleMouseUp={handlers.handleMouseUp}\n              />\n            )\n          )\n        }\n      </div>\n    </>\n  )\n}\n\nexport default PathfindingVisualizer\n","import { makeStyles, Paper, Typography } from '@material-ui/core';\nimport React from 'react';\nimport GithubCorner from 'react-github-corner';\nimport PathfindingVisualizer from './components/PathfindingVisualizer';\n\nconst useStyles = makeStyles((theme) => ({\n  paper: {\n    flexGrow: 1,\n    maxWidth: 700,\n    margin: \"50px auto\",\n    padding: theme.spacing(5),\n    textAlign: 'center',\n  },\n  start: {\n    color: 'green',\n    fontWeight: 'bold',\n  },\n  end: {\n    color: 'red',\n    fontWeight: 'bold',\n  },\n  wall: {\n    color: 'black',\n    fontWeight: 'bold',\n  },\n}));\n\nfunction App() {\n  const classes = useStyles();\n  const url = 'https://github.com/kenfj/pathfinding-visualizer-react'\n\n  return (\n    <Paper elevation={5} className={classes.paper}>\n      <GithubCorner href={url} />\n      <h1>Pathfinding Visualizer</h1>\n      <Typography variant=\"body1\" gutterBottom>\n        Click to create <span className={classes.wall}>WALL</span><br />\n        Drag <span className={classes.start}>START</span> and <span className={classes.end}>END</span>\n      </Typography>\n      <PathfindingVisualizer nRows={20} nCols={30} />\n      <Typography variant=\"caption\" display=\"block\" gutterBottom>\n        source code: <a href={url}>{url}</a>\n      </Typography>\n    </Paper >\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}