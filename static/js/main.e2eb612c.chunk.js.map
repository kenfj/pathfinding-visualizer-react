{"version":3,"sources":["algorithms/NodeType.tsx","algorithms/Dijkstra.tsx","algorithms/Vertex.tsx","hooks/useMouseEventHandlers.tsx","components/Node.tsx","components/PathfindingVisualizer.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["NodeType","Dijkstra","grid","startNode","endNode","openSet","visited","distance","length","current","pop","isVisited","push","updateNeighbors","nodes","sort","nodeA","nodeB","shift","node","neighbors","i","j","filter","neighbor","isWall","getNeighbors","prevNode","includes","Vertex","nodeType","Default","Infinity","this","Wall","useMouseEventHandlers","start","end","setGrid","setStart","setEnd","clear","useState","isMousePressed","setIsMousePressed","isDraggingStart","setIsDraggingStart","isDraggingEnd","setIsDraggingEnd","isUpdatingToWall","setIsUpdatingToWall","updateWall","newType","newNode","newGrid","slice","handleMouseDown","Start","End","handleMouseEnter","updateStart","updateEnd","handleMouseUp","useStyles","makeStyles","theme","item","props","border","gridRow","gridCol","backgroundColor","vertex","wall","Node","classes","classWall","className","ref","nodeRef","title","onMouseDown","onMouseEnter","onMouseUp","container","display","gridTemplateRows","nRows","gridTemplateColumns","nCols","justifyContent","margin","shortestPath","PathfindingVisualizer","p","startEnd","Math","trunc","initialRefs","Array","from","_","createRef","refs","initialGrid","initialNodeType","forEach","row","reset","classList","remove","handlers","animate","visitedNodes","setTimeout","add","animateShortestPath","Button","variant","style","textTransform","onClick","path","unshift","backtrackToStart","map","paper","flexGrow","maxWidth","padding","spacing","textAlign","color","fontWeight","App","url","Paper","elevation","href","Typography","gutterBottom","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e2eb612c.chunk.js","sourcesContent":["export enum NodeType {\n  Default,\n  Start,\n  End,\n  Wall,\n}\n","import { Vertex } from \"./Vertex\";\n\nexport function Dijkstra(grid: Vertex[][], startNode: Vertex, endNode: Vertex) {\n  const openSet = [startNode]\n  const visited: Vertex[] = []\n  startNode.distance = 0\n\n  while (!!openSet.length) {\n    const current = pop(openSet)\n\n    if (current === endNode) return visited\n\n    current.isVisited = true\n    visited.push(current)\n\n    updateNeighbors(current)\n  }\n\n  // works like a priority queue\n  function pop(nodes: Vertex[]) {\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n    return nodes.shift()!\n  }\n\n  function updateNeighbors(node: Vertex) {\n    const neighbors = getNeighbors(node)\n\n    for (const neighbor of neighbors) {\n      neighbor.distance = node.distance + 1\n      neighbor.prevNode = node\n\n      if (!openSet.includes(neighbor))\n        openSet.push(neighbor)\n    }\n  }\n\n  function getNeighbors(node: Vertex) {\n    const neighbors = []\n    const { i, j } = node\n\n    if (i > 0)\n      neighbors.push(grid[i - 1][j])\n    if (i < grid.length - 1)\n      neighbors.push(grid[i + 1][j])\n    if (j > 0)\n      neighbors.push(grid[i][j - 1])\n    if (j < grid[0].length - 1)\n      neighbors.push(grid[i][j + 1])\n\n    return neighbors.filter(neighbor =>\n      !neighbor.isWall() &&\n      !neighbor.isVisited\n    )\n  }\n}\n\nexport function backtrackToStart(node: Vertex) {\n  const path = [node]\n\n  while (node.prevNode) {\n    path.unshift(node.prevNode)\n    node = node.prevNode!\n  }\n\n  return path\n}\n","import { NodeType } from \"./NodeType\";\n\nexport class Vertex {\n  constructor(\n    readonly i: number,\n    readonly j: number,\n    public nodeType: NodeType = NodeType.Default,\n    public distance: number = Infinity,\n    public prevNode: Vertex | null = null,\n    public isVisited: boolean = false,\n  ) { }\n\n  public reset() {\n    this.distance = Infinity\n    this.prevNode = null\n    this.isVisited = false\n  }\n\n  public isWall() {\n    return this.nodeType === NodeType.Wall\n  }\n}\n","import { Dispatch, SetStateAction, useState } from \"react\";\nimport { NodeType } from \"../algorithms/NodeType\";\nimport { Vertex } from \"../algorithms/Vertex\";\nimport { Coordinates } from \"../components/Coordinates\";\n\nconst useMouseEventHandlers = (\n  grid: Vertex[][],\n  start: Coordinates,\n  end: Coordinates,\n  setGrid: Dispatch<SetStateAction<Vertex[][]>>,\n  setStart: Dispatch<SetStateAction<Coordinates>>,\n  setEnd: Dispatch<SetStateAction<Coordinates>>,\n  clear: () => void,\n) => {\n  const [isMousePressed, setIsMousePressed] = useState<boolean>(false);\n  const [isDraggingStart, setIsDraggingStart] = useState<boolean>(false);\n  const [isDraggingEnd, setIsDraggingEnd] = useState<boolean>(false);\n  const [isUpdatingToWall, setIsUpdatingToWall] = useState<boolean>(false);\n\n  const updateStart = (i: number, j: number) => {\n    const newGrid = grid.slice()\n\n    newGrid[start.i][start.j] = new Vertex(start.i, start.j)\n    newGrid[i][j] = new Vertex(i, j, NodeType.Start)\n\n    setGrid(newGrid)\n    setStart({ i, j })\n  }\n\n  const updateEnd = (i: number, j: number) => {\n    const newGrid = grid.slice()\n\n    newGrid[end.i][end.j] = new Vertex(end.i, end.j)\n    newGrid[i][j] = new Vertex(i, j, NodeType.End)\n\n    setGrid(newGrid)\n    setEnd({ i, j })\n  }\n\n  const updateWall = (i: number, j: number) => {\n    const newType = isUpdatingToWall ? NodeType.Wall : NodeType.Default\n    const newNode = new Vertex(i, j, newType)\n\n    const newGrid = grid.slice()\n    newGrid[i][j] = newNode\n\n    setGrid(newGrid)\n  }\n\n  const handleMouseDown = (i: number, j: number) => {\n    setIsMousePressed(true)\n\n    if (grid[i][j].nodeType === NodeType.Start) {\n      setIsDraggingStart(true)\n    } else if (grid[i][j].nodeType === NodeType.End) {\n      setIsDraggingEnd(true)\n    } else {\n      updateWall(i, j)\n    }\n  }\n\n  const handleMouseEnter = (i: number, j: number) => {\n    setIsUpdatingToWall(grid[i][j].nodeType !== NodeType.Wall)\n    if (!isMousePressed) return\n\n    if (isDraggingStart) {\n      updateStart(i, j)\n    } else if (isDraggingEnd) {\n      updateEnd(i, j)\n    } else {\n      updateWall(i, j)\n    }\n  }\n\n  const handleMouseUp = (i: number, j: number) => {\n    setIsMousePressed(false)\n\n    if (isDraggingStart || isDraggingEnd)\n      clear()\n\n    setIsDraggingStart(false)\n    setIsDraggingEnd(false)\n    setIsUpdatingToWall(grid[i][j].nodeType !== NodeType.Wall)\n  }\n\n  return {\n    handleMouseDown,\n    handleMouseEnter,\n    handleMouseUp,\n  }\n}\n\nexport default useMouseEventHandlers\n","import { makeStyles, Theme } from '@material-ui/core';\nimport React, { RefObject } from 'react';\nimport { NodeType } from '../algorithms/NodeType';\nimport { Vertex } from '../algorithms/Vertex';\n\nconst useStyles = makeStyles<Theme, Props>((theme) => ({\n  item: props => ({\n    border: \"1px solid lightgray\",\n    gridRow: `${props.i + 1}`,\n    gridCol: `${props.j + 1}`,\n    backgroundColor: `${props.vertex.nodeType === NodeType.Start ? 'green' : props.vertex.nodeType === NodeType.End ? 'red' : ''}`\n  }),\n  wall: {\n    backgroundColor: 'black'\n  },\n}));\n\ntype Props = {\n  i: number\n  j: number\n  nodeRef: RefObject<HTMLDivElement>\n  vertex: Vertex\n  handleMouseDown: (i: number, j: number) => void\n  handleMouseEnter: (i: number, j: number) => void\n  handleMouseUp: (i: number, j: number) => void\n}\n\nfunction Node(props: Props) {\n  const classes = useStyles(props);\n\n  const handleMouseDown = () => {\n    props.handleMouseDown(props.i, props.j)\n  }\n\n  const handleMouseEnter = () => {\n    props.handleMouseEnter(props.i, props.j)\n  }\n\n  const handleMouseUp = () => {\n    props.handleMouseUp(props.i, props.j)\n  }\n\n  const classWall = props.vertex.nodeType === NodeType.Wall ? classes.wall : ''\n\n  return (\n    <div\n      className={`${classes.item} ${classWall}`}\n      ref={props.nodeRef}\n      title={`${props.i}, ${props.j}`}\n      onMouseDown={handleMouseDown}\n      onMouseEnter={handleMouseEnter}\n      onMouseUp={handleMouseUp}\n    />\n  )\n}\n\nexport default Node\n","import { Button, makeStyles, Theme } from '@material-ui/core';\nimport React, { createRef, RefObject, useState } from 'react';\nimport { backtrackToStart, Dijkstra } from '../algorithms/Dijkstra';\nimport { NodeType } from '../algorithms/NodeType';\nimport { Vertex } from '../algorithms/Vertex';\nimport useMouseEventHandlers from '../hooks/useMouseEventHandlers';\nimport { Coordinates } from './Coordinates';\nimport Node from './Node';\n\nconst useStyles = makeStyles<Theme, Props>((theme) => ({\n  container: props => ({\n    display: 'grid',\n    gridTemplateRows: `repeat(${props.nRows}, 20px)`,\n    gridTemplateColumns: `repeat(${props.nCols}, 20px)`,\n    justifyContent: 'center',\n    margin: '50px auto',\n  }),\n  visited: {\n    backgroundColor: 'lightgreen'\n  },\n  shortestPath: {\n    backgroundColor: 'yellow'\n  },\n}));\n\nconst initialStartEnd = (p: Props): Coordinates[] => {\n  return [\n    { i: Math.trunc(p.nRows / 2), j: Math.trunc(p.nCols / 5) },\n    { i: Math.trunc(p.nRows / 2), j: Math.trunc(p.nCols * 4 / 5) - 1 }\n  ]\n}\n\nconst initialNodeType = (i: number, j: number, start: Coordinates, end: Coordinates) => {\n  return (\n    i === start.i && j === start.j ? NodeType.Start :\n      i === end.i && j === end.j ? NodeType.End :\n        NodeType.Default\n  )\n}\n\ntype Props = {\n  nRows: number\n  nCols: number\n}\n\nfunction PathfindingVisualizer(props: Props) {\n  const classes = useStyles(props);\n\n  const startEnd = initialStartEnd(props)\n  const [start, setStart] = useState<Coordinates>(startEnd[0]);\n  const [end, setEnd] = useState<Coordinates>(startEnd[1]);\n\n  const initialRefs =\n    Array.from({ length: props.nRows }, _ =>\n      Array.from({ length: props.nCols }, _ =>\n        createRef<HTMLDivElement>()\n      )\n    )\n  const [refs] = useState<RefObject<HTMLDivElement>[][]>(initialRefs);\n\n  const initialGrid =\n    Array.from({ length: props.nRows }, (_, i) =>\n      Array.from({ length: props.nCols }, (_, j) => {\n        const nodeType = initialNodeType(i, j, start, end)\n        return new Vertex(i, j, nodeType)\n      })\n    )\n  const [grid, setGrid] = useState<Vertex[][]>(initialGrid);\n\n  const clear = () => {\n    refs.forEach((row, i) =>\n      row.forEach((ref, j) => {\n        grid[i][j].reset()\n        ref.current?.classList.remove(classes.visited, classes.shortestPath)\n      })\n    )\n  }\n\n  const handlers = useMouseEventHandlers(grid, start, end, setGrid, setStart, setEnd, clear)\n\n  const visualize = () => {\n    clear()\n\n    const startNode = grid[start.i][start.j]\n    const endNode = grid[end.i][end.j]\n    const visitedNodes = Dijkstra(grid, startNode, endNode);\n    const shortestPath = backtrackToStart(endNode);\n\n    animate(visitedNodes!, shortestPath);\n  }\n\n  const animate = (visitedNodes: Vertex[], shortestPath: Vertex[]) => {\n    for (let i = 1; i < visitedNodes.length - 1; i++) {\n      setTimeout(() => {\n        const node = visitedNodes[i];\n        const ref = refs[node.i][node.j].current!\n        ref.classList.add(classes.visited)\n      }, 10 * i);\n\n      if (i === visitedNodes.length - 2) {\n        setTimeout(() => {\n          animateShortestPath(shortestPath);\n        }, 10 * i);\n        return;\n      }\n    }\n  }\n\n  const animateShortestPath = (shortestPath: Vertex[]) => {\n    for (let i = 1; i < shortestPath.length - 1; i++) {\n      setTimeout(() => {\n        const node = shortestPath[i];\n        const ref = refs[node.i][node.j].current!\n        ref.classList.add(classes.shortestPath)\n      }, 50 * i);\n    }\n  }\n\n  return (\n    <>\n      <Button variant=\"contained\" style={{ textTransform: 'none' }} onClick={visualize}>\n        Visualize Dijkstra's Algorithm\n      </Button>\n      <div className={classes.container}>\n        {\n          refs.map((row, i) =>\n            row.map((node, j) =>\n              <Node\n                i={i} j={j}\n                key={`node-${i}-${j}`}\n                nodeRef={node}\n                vertex={grid[i][j]}\n                handleMouseDown={handlers.handleMouseDown}\n                handleMouseEnter={handlers.handleMouseEnter}\n                handleMouseUp={handlers.handleMouseUp}\n              />\n            )\n          )\n        }\n      </div>\n    </>\n  )\n}\n\nexport default PathfindingVisualizer\n","import { makeStyles, Paper, Typography } from '@material-ui/core';\nimport React from 'react';\nimport GithubCorner from 'react-github-corner';\nimport PathfindingVisualizer from './components/PathfindingVisualizer';\n\nconst useStyles = makeStyles((theme) => ({\n  paper: {\n    flexGrow: 1,\n    maxWidth: 700,\n    margin: \"50px auto\",\n    padding: theme.spacing(5),\n    textAlign: 'center',\n  },\n  start: {\n    color: 'green',\n    fontWeight: 'bold',\n  },\n  end: {\n    color: 'red',\n    fontWeight: 'bold',\n  },\n  wall: {\n    color: 'black',\n    fontWeight: 'bold',\n  },\n}));\n\nfunction App() {\n  const classes = useStyles();\n  const url = 'https://github.com/kenfj/pathfinding-visualizer-react'\n\n  return (\n    <Paper elevation={5} className={classes.paper}>\n      <GithubCorner href={url} />\n      <h1>Pathfinding Visualizer</h1>\n      <Typography variant=\"body1\" gutterBottom>\n        Click to create <span className={classes.wall}>WALL</span><br />\n        Drag <span className={classes.start}>START</span> and <span className={classes.end}>END</span>\n      </Typography>\n      <PathfindingVisualizer nRows={20} nCols={30} />\n      <Typography variant=\"caption\" display=\"block\" gutterBottom>\n        source code: <a href={url}>{url}</a>\n      </Typography>\n    </Paper >\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}